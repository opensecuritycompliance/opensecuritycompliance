import json
from typing import overload
import uuid
from compliancecowcards.structs import cards
#As per the selected app, we're importing the app package 
from appconnections.snykappconnector import snykappconnector
import pandas as pd
from collections import defaultdict

class Task(cards.AbstractTask):

    def execute(self) -> dict:

        api_url, self.resource_url = self.get_snyk_urls(self.task_inputs.user_object.app.application_url)
        
        self.snykapp = snykappconnector.SnykAppConnector(
            app_url=api_url,
            app_port=self.task_inputs.user_object.app.application_port,
            user_defined_credentials=snykappconnector.UserDefinedCredentials.from_dict(
                self.task_inputs.user_object.app.user_defined_credentials)
        )
        response = {}
        IncludeCriteria = self.task_inputs.user_inputs.get("IncludeCriteria") or "/target/*/project/*"
        ExcludeCriteria = self.task_inputs.user_inputs.get("ExcludeCriteria") or "/target//project/"

        org_id, user_name, error = self.snykapp.get_self_details()
        if error:
            log_file_url, error = self.upload_log_file([{ "Error": error }])
            if error:
                return { "Error": error }
            return { "LogFile": log_file_url }
        
        all_targets, error = self.snykapp.get_targets_by_org(org_id)
        if error:
            log_file_url, upload_error = self.upload_log_file([{"Error": error}])
            if upload_error:
                return {"Error": upload_error}
            return {"LogFile": log_file_url}
        
        target_list = [
            {
                "id": item["id"],
                "repo": item["attributes"]["display_name"],
            }
            for item in all_targets
        ]
        log_messages = []
        filtered_target_ids, error = self.filter_targets(target_list, IncludeCriteria, ExcludeCriteria)
        if error:
            log_messages.append({"Error": error})
        
        if filtered_target_ids == []:
            log_file_url, error = self.upload_log_file([{ "Error": "No data found. The filtered target list is empty." }])
            if error:
                return { "Error": error }
            return { "LogFile": log_file_url }

        project_data = []

        project_data, error = self.snykapp.get_projects_by_org_and_target(org_id, target_ids=filtered_target_ids)
        if error:
            log_file_url, error = self.upload_log_file([{ "Error": error }])
            if error:
                return { "Error": error }
            return { "LogFile": log_file_url }
        
        filtered_projects, filtered_target_names, error = self.filter_projects(
            project_data, IncludeCriteria, ExcludeCriteria
        )
        if error:
            log_messages.append({"Error": error})

        if not filtered_projects:
            log_file_url, error = self.upload_log_file([{
                "Error": f"No projects found for the specified target(s): {filtered_target_names}."
            }])
            if error:
                return {"Error": error}
            return {"LogFile": log_file_url}

        issues_data = []
        for project_id, (resource_name, target_name) in filtered_projects.items():
            current_data, error = self.snykapp.get_issues_by_org_and_project(org_id, project_id=project_id)
            if error:
                log_file_url, upload_error = self.upload_log_file([{"Error": error}])
                if upload_error:
                    return {"Error": upload_error}
                return {"LogFile": log_file_url}

            for issue in current_data:
                issue['project_id'] = project_id
                issue['resource_name'] = resource_name
                issue['target_name'] = target_name
            issues_data.extend(current_data)

        if log_messages:
            log_file_url, error = self.upload_log_file(log_messages)
            if error:
                return {"Error": error}
            response["LogFile"] = log_file_url
        
        standardized_df = self.standardize_issues_data(issues_data, user_name)
        standardized_formatted_df = pd.DataFrame(standardized_df)
        file_name = "SnykContainerScannerReport"
        scanner_report_file_url, error = self.upload_df_as_parquet_file_to_minio(
            df=standardized_formatted_df,
            file_name=file_name
        )
        if error:
            return { "Error": f"Error while uploading {file_name} file :: {error}" }
        response["SnykContainerScannerReport"] = scanner_report_file_url

        return response
    
    def standardize_issues_data(self, issues_data, username):
        df = pd.DataFrame(issues_data)
        df["System"] = "snyk"
        df["Source"] = "compliancecow"
        df["ResourceID"] = df["project_id"].fillna("N/A")
        df["ResourceName"] = df["resource_name"]
        df["ResourceType"] = "image"
        df["ResourceLocation"] = "N/A"
        df["ResourceTags"] = "N/A"
        df["IssueKey"] = df['attributes'].apply(lambda x: x['key'] if 'key' in x else None)
        df["ResourceURL"] = self.form_issue_url(df, username)
        df["Representation"] = df['attributes'].apply(
            lambda x: x.get('coordinates', [{}])[0].get('representations', [{'dependency': {'package_name': 'N/A', 'package_version': 'N/A'}}]) if 'coordinates' in x else [{'dependency': {'package_name': 'N/A', 'package_version': 'N/A'}}]
        )
        df["IssueName"] = df['attributes'].apply(lambda x: x['title'] if 'title' in x else None)
        df["IssueType"] = df['attributes'].apply(lambda x: x['type'] if 'type' in x else None)
        df["CVEID"] = df['attributes'].apply(
                        lambda x: next((problem['id'] for problem in x.get('problems', []) if problem['id'].startswith('CVE')), "N/A")
                        )
        df["Severity"] = df['attributes'].apply(lambda x: x['effective_severity_level'] if 'effective_severity_level' in x else None)
        df["EPSSPercentile"] = df["CVEID"].apply(lambda cve_id: (lambda percent: percent if percent else "N/A")(self.snykapp.get_epss_score_for_cve(cve_id)[1]))
        df["RiskScore"] = df['attributes'].apply(lambda x: x.get('risk', {}).get('score', {}).get('value', None))
        df["IssueStatus"] = df['attributes'].apply(lambda x: x['status'] if 'status' in x else None)
        df["IssueCreatedDateTime"] = df['attributes'].apply(lambda x: x['created_at'] if 'created_at' in x else None)
        df["IsIgnored"] = df['attributes'].apply(lambda x: x['ignored'] if 'ignored' in x else None)
        df["ValidationStatusCode"] = ""
        df["ValidationStatusNotes"] = ""
        df["ComplianceStatus"] = ""
        df["ComplianceStatusReason"] = ""
        df["EvaluatedTime"] = df['attributes'].apply(lambda x: x['updated_at'] if 'updated_at' in x else None)
        df["UserAction"] = ""
        df["ActionStatus"] = ""
        df["ActionResponseURL"] = ""
        df[["ValidationStatusCode", "ValidationStatusNotes", "ComplianceStatus", "ComplianceStatusReason"]] = df.apply(
            lambda row: pd.Series(self.map_compliance_details(row["Severity"], row["EPSSPercentile"], row["IssueStatus"], row["IsIgnored"])),
            axis=1
        )

        standardized_columns = [
            "System", "Source", "ResourceID", "ResourceName", "ResourceType", "ResourceLocation",
            "ResourceTags", "ResourceURL", "IssueKey", "IssueName", "IssueType",
            "IssueCreatedDateTime", "IssueStatus", "IsIgnored", "Representation", "CVEID", "Severity", "EPSSPercentile", "RiskScore",
            "ValidationStatusCode", "ValidationStatusNotes", "ComplianceStatus", "ComplianceStatusReason",
            "EvaluatedTime", "UserAction", "ActionStatus", "ActionResponseURL"
        ]
        
        return df[standardized_columns]
    
    def form_issue_url(self, issue_data_df, username):
        url = self.resource_url
        base_url = url + '/org/'
        project_path = "/project/"
        
        urls = issue_data_df.apply(
            lambda row: f"{base_url}{username}{project_path}{row['project_id']}"
            if pd.notna(row['project_id']) else "N/A",
            axis=1
        )
        
        return urls
    
    def map_compliance_details(self, severity, epss, issue_status, is_ignored):
        if is_ignored:
            return (
                "IGNORED_ISSUE",
                "The vulnerability has been reviewed and intentionally ignored as part of the remediation process, regardless of its EPSS Percentile.",
                "COMPLIANT",
                "The issue is ignored following a review as part of remediation, thus considered compliant."
            )
        
        if issue_status == "resolved":
            return (
                "RESOLVED_ISSUE",
                "The vulnerability has been reviewed and resolved as part of the remediation process, regardless of its EPSS Percentile.",
                "COMPLIANT",
                "The issue is resolved following a review as part of remediation, thus considered compliant."
            )
        
        if epss == "N/A":
            epss_category = "NO_EPSS"
            epss_float = None
        else:
            epss_float = float(epss)
            if epss_float < 50:
                epss_category = "LOW_EPSS"
            elif 50 <= epss_float < 70:
                epss_category = "MED_EPSS"
            elif 70 <= epss_float < 90:
                epss_category = "HIGH_EPSS"
            else:  # epss_float >= 90
                epss_category = "CRT_EPSS"

        severity = severity.lower()
        validation_code = f"OPEN_ISSUE_{severity.upper()}_SEV_{epss_category}"
        
        if epss_category == "NO_EPSS":
            validation_notes = "Contains open issues with no EPSS Percentile."
        else:
            validation_notes = f"Contains open issues with an EPSS Percentile {'< 50' if epss_category == 'LOW_EPSS' else 'between 50-70' if epss_category == 'MED_EPSS' else 'between 70-90' if epss_category == 'HIGH_EPSS' else '> 90'}."

        if severity == "low":
            compliance_status = "COMPLIANT" if epss == "N/A" or epss_float < 70 else "NON_COMPLIANT"
        elif severity == "medium":
            compliance_status = "COMPLIANT" if epss == "N/A" or epss_float < 70 else "NON_COMPLIANT"
        else:  # high or critical severity
            compliance_status = "NON_COMPLIANT"

        severity_display = severity.capitalize() + "-risk"
        compliance_reason = (
            f"The issues are {severity_display} (EPSS {epss_category.replace('_', ' ').lower()}) and are open, "
            f"indicating {'compliance' if compliance_status == 'COMPLIANT' else 'non-compliance'}."
        )

        return validation_code, validation_notes, compliance_status, compliance_reason

    def filter_targets(self, target_data, include_criteria, exclude_criteria):

        include_criteria, error = self.parse_criteria(include_criteria)
        if error:
            return None, error
        exclude_criteria, error = self.parse_criteria(exclude_criteria)
        if error:
            return None, error

        targets_to_exclude = set()
        for crit in exclude_criteria:
            if crit["targets"] == ["*"] and crit["projects"] == ["*"]:
                return None, "Cannot exclude all Repositories."
            elif crit["projects"] == ["*"]:
                targets_to_exclude.update(crit["targets"])
            else:
                continue

        non_excluded_targets = [
            target for target in target_data
            if target.get("repo") not in targets_to_exclude
        ]
        non_excluded_target_dict = {target["repo"]: target["id"] for target in non_excluded_targets}

        filtered_target_ids = []
        invalid_include_crit_targets = []

        for crit in include_criteria:
            targets_to_include = crit["targets"]
            
            if targets_to_include == ["*"]:
                filtered_target_ids.extend(non_excluded_target_dict.values())
            else:
                targets_set = set(targets_to_include)
                available_targets = targets_set.intersection(non_excluded_target_dict.keys())
                missing_targets = targets_set.difference(non_excluded_target_dict.keys())
                
                filtered_target_ids.extend(non_excluded_target_dict[target] for target in available_targets)
                
                invalid_include_crit_targets.extend(missing_targets)

        if invalid_include_crit_targets and filtered_target_ids:
            return filtered_target_ids, f"Could not find target/targets with name(s): {', '.join(invalid_include_crit_targets)}"
        else:
            return filtered_target_ids, None
    
    def filter_projects(self, project_data, include_criteria, exclude_criteria):

        include_criteria, error = self.parse_criteria(include_criteria)
        if error:
            return None, None, error
        exclude_criteria, error = self.parse_criteria(exclude_criteria)
        if error:
            return None, None, error

        projects_to_exclude = set()
        for crit in exclude_criteria:
            exclude_target_names = crit.get("targets", [])
            if crit["projects"] == ["*"]:
                for project in project_data:
                    name_parts = project.get("attributes", {}).get("name").split(":")
                    target_name = name_parts[0]
                    project_name = name_parts[1] if len(name_parts) > 1 else None
                    if target_name in exclude_target_names:
                        if not project_name or project_name in crit["projects"]:
                            projects_to_exclude.add(project.get("id"))
            else:
                for project in project_data:
                    name_parts = project.get("attributes", {}).get("name").split(":")
                    target_name = name_parts[0]
                    project_name = name_parts[1] if len(name_parts) > 1 else None
                    if target_name in exclude_target_names:
                        if not project_name or project_name in crit["projects"]:
                            projects_to_exclude.add(project.get("id"))

        filtered_projects = {}  # Dictionary to map project_id -> (resource_name, target_name)
        log_messages = set()

        project_name_to_data = defaultdict(list)
        for project in project_data:
            name = project.get("attributes", {}).get("name", "")
            if ":" in name:
                key = name.split(":")[1]
                project_name_to_data[key].append(project)

        for crit in include_criteria:
            projects_to_include = crit["projects"]
            target_to_check = crit.get("targets")
            if projects_to_include == ["*"]:
                for project in project_data:
                    if isinstance(project, dict):
                        project_id = project.get("id")
                        if project_id and project_id not in projects_to_exclude:
                            resource_name = project.get("attributes", {}).get("name", "N/A")
                            name_parts = resource_name.split(":")
                            target_name = name_parts[0] if name_parts else "N/A"

                            filtered_projects[project_id] = (resource_name, target_name)
                    else:
                        log_messages.add(f"Unexpected project format: {project}")
            else:
                projects_to_include_set = set(projects_to_include)

                for target in target_to_check:
                    for project_name in projects_to_include_set:
                        projects = project_name_to_data.get(project_name, [])
                        if not projects:
                            log_messages.add(
                                f"Project '{project_name}' does not exist in target '{target}'."
                            )
                            continue

                        for project in projects:
                            if isinstance(project, dict):
                                project_id = project.get("id")
                                resource_name = project.get("attributes", {}).get("name", "N/A")
                                name_parts = resource_name.split(":")
                                target_name = name_parts[0] if name_parts else "N/A"

                                if (target_name == target or target == '*') and project_id not in projects_to_exclude:
                                    filtered_projects[project_id] = (resource_name, target_name)
                                elif target_name != target:
                                    log_messages.add(
                                        f"Project '{project_name}' does not exist in target '{target}'."
                                    )
                            else:
                                log_messages.add(
                                    f"Project '{project_name}' does not exist in target '{target}'."
                                )

        filtered_target_names = list(set(value[1] for value in filtered_projects.values()))

        return (
            filtered_projects,
            filtered_target_names,
            "\n".join(log_messages) if log_messages else None
        )
    
    def parse_criteria(self, criteria):
        parsed_criteria = []

        if not criteria.startswith('/target/'):
            return None, "Criteria should start with '/target/'."
        
        path = criteria[len('/target/'):]
        
        target = path.split('/project/')[0]
        target_list = []
        target_list = target.split(',')
        
        project = path.split('/project/')[-1]
        project_list = []
        if project.endswith('/'):
            project = project.rstrip('/')
            project_list = project.split(',')
        else:
            project_list = project.split(',')

        parsed_criteria.append({
                "targets": target_list,
                "projects": project_list
            })

        return parsed_criteria, None
    
    def get_snyk_urls(self, base_url):
        api_urls = {
            "us": "https://api.snyk.io",
            "eu": "https://api.eu.snyk.io",
            "au": "https://api.au.snyk.io"
        }
        resource_urls = {
            "us": "https://app.snyk.io",
            "eu": "https://app.eu.snyk.io",
            "au": "https://app.au.snyk.io"
        }

        region = "us" # Default Region
        if "eu" in base_url:
            region = "eu"
        elif "au" in base_url:
            region = "au"

        api_url = api_urls.get(region)
        self.resource_url = resource_urls.get(region)

        return api_url, self.resource_url
    
    def upload_log_file(self, error_data):
        if not isinstance(error_data, list):
            error_data = [error_data]
        log_file_content = json.dumps(error_data, indent=4)
        file_name = f"LogFile-{str(uuid.uuid4())}.json"
        content_type = "application/json"
        file_url, error = self.upload_file_to_minio(
            file_content=log_file_content.encode('utf-8'),
            file_name=file_name,
            content_type=content_type
        )
        if error:
            return None, f"Error while uploading LogFile: {error}"
        return file_url, None