from compliancecowcards.structs import cards
from compliancecowcards.structs import cards
from applicationtypes.snykappconnector import snykappconnector
import pandas as pd
import json
import uuid
from compliancecowcards.utils import cowdictutils

MINIO_PLACEHOLDER = "<<MINIO_FILE_PATH>>"

class Task(cards.AbstractTask):

    def execute(self) -> dict:

        config_file_path = self.task_inputs.user_inputs.get("ConfigFile" , "")
        if not config_file_path or config_file_path == "" or config_file_path == MINIO_PLACEHOLDER:
            return self.upload_log_file([{"Error" : "ConfigFile is missing."}])
        
        config_file_bytes,error =  self.download_file_from_minio(config_file_path)
        if error :
            return self.upload_log_file(error)
        
        if not config_file_bytes :
            return self.upload_log_file([{"Error" : "ConfigFile cannot be empty."}])
        
        config_data = {}
        config_json_str = config_file_bytes.decode('utf-8')
        config_data = json.loads(config_json_str)
            
        
        if not cowdictutils.is_valid_key(config_data , "OrganizationName") :
            return self.upload_log_file([{"Error" : "OrganizationName is missing in config file"}])
        
        if not cowdictutils.is_valid_key(config_data , "Projects") :
            return self.upload_log_file([{"Error" : "Projects is missing in config file"}])

        
        organization_name = config_data["OrganizationName"]
        projects = config_data["Projects"]
        
        if (
            self.task_inputs == None 
            or self.task_inputs.user_object == None 
            or not self.task_inputs.user_object.app 
            or not  self.task_inputs.user_object.app.user_defined_credentials
        ) :
            return self.upload_log_file( [{"Error": "user object is missing "} ])

        self.snyk_connector = snykappconnector.SnykAppConnector(app_url = self.task_inputs.user_object.app.application_url , 
            user_defined_credentials=snykappconnector.UserDefinedCredentials.from_dict(
                self.task_inputs.user_object.app.user_defined_credentials
            )
        )

        org_id,error = self.snyk_connector.get_org_id_using_name(organization_name)
        if error :
            return self.upload_log_file([error])
        issue_report = []
        
        errors = []

        for project in projects :
            image_details,error = self.snyk_connector.get_image_details(org_id ,project )
            if error :
                errors.append(error)
                continue
            issues,error = self.snyk_connector.get_snyk_issues_report(org_id ,project )
            if error :  
                errors.append(error)
                continue
            organized_data = self.organize_data(issues , image_details)
            issue_report.extend(organized_data)
        
        
        response = {}
        if len(errors) > 0:
            log_file_response = self.upload_log_file(errors)
            if cowdictutils.is_valid_key(log_file_response, 'LogFile'):
                response['LogFile'] = log_file_response["LogFile"]
            elif cowdictutils.is_valid_key(log_file_response, 'Error'):
                    return log_file_response
        
        output_file_path, error = self.upload_output_file(pd.DataFrame(issue_report))
        if error :
            return self.upload_log_file(error)
        
        response["SnykScanReport"] = output_file_path
        
        return response
        
    def organize_data(self, reports, image_details):
        
        flattened_reports = pd.json_normalize(reports)
        
        flattened_reports = flattened_reports.assign(
            System="snyk",
            Source="compliancecow",
            ResourceID=image_details.get("id"),
            ResourceName=image_details.get("name"),
            ResourceType="container-image",
            ResourceLocation="N/A",
            ResourceURL=image_details.get("browseUrl"),
            ResourceTag=[[image_details.get("imageTag")]] * len(flattened_reports),
            CVEID=flattened_reports['issueData.identifiers.CVE'].apply(
                lambda x: x[0] if isinstance(x, list) and len(x) > 0 else ""),
            ScanDateTime=self.snyk_connector.get_current_datetime(),
            UserAction="",
            ActionStatus="",
            ActionResponseURL=""
        )
        
        flattened_reports.rename(columns={
            "pkgName": "PackageName",
            "pkgVersions": "InstalledVersion",
            "issueData.nearestFixedInVersion": "FixedVersion",
            "issueData.title": "Title",
            "issueData.description": "Description",
            "issueData.severity": "Severity",
            "issueData.CVSSv3": "CVSSV3",
            "issueData.cvssScore": "CVSSScore",
            "priorityScore": "PriorityScore",
            "issueData.cvssDetails": "CVEReferences"
        }, inplace=True)
        
        flattened_reports['EPSSPercentile']=flattened_reports['CVEID'].apply(lambda cve_id: self.snyk_connector.get_epss_score_for_cve(cve_id)[1])
        flattened_reports["InstalledVersion"] = flattened_reports["InstalledVersion"].apply(lambda x : pd.Series(x).drop_duplicates())
        flattened_reports['Description'] = flattened_reports['Description'].str.replace("## NVD Description\n**_Note:_** _" , "").str.split("\n## References\n- ").str[0]

        columns = [
            'System' ,'Source','ResourceID', 'ResourceName', 'ResourceType', 'ResourceLocation', 'ResourceTag', 'ResourceURL', 'Source', 'CVEID', 'PackageName', 'InstalledVersion', 'FixedVersion',
            'Title', 'Description', 'ScanDateTime', 'Severity', 'CVSSV3', 'CVSSScore', 'PriorityScore',
            'EPSSPercentile', 'CVEReferences','UserAction','ActionStatus','ActionResponseURL'
        ]
        
        organized_data = flattened_reports[columns].to_dict(orient='records')
        
        return organized_data
    
    def upload_log_file(self, error_msg):
        absolute_file_path, error = self.upload_file_to_minio(
            file_name=f'LogFile-{str(uuid.uuid4())}.json',
            file_content=json.dumps(error_msg).encode(),
            content_type='application/json',
        )
        if error:
            return {'Error': error}
        return {'LogFile': absolute_file_path}
    
    def upload_output_file(self, data):
        output_df = pd.DataFrame(data)
        absolute_file_path, error = self.upload_df_as_parquet_file_to_minio(
            df=output_df,
            file_name='SnykScanReport'
        )
        return absolute_file_path, error