from compliancecowcards.structs import cards
from applicationtypes.privacybisonconnector import privacybisonconnector
from compliancecowcards.utils import cowdictutils
import json
from datetime import datetime
import uuid
import urllib.parse
from publicsuffix2 import PublicSuffixList

class Task(cards.AbstractTask):

    def execute(self) -> dict:

        error = self.check_inputs()
        if error:
            log_file_url, error = self.upload_log_file({'error': error})
            if error:
                return {'error': error}
            return {"LogFile": log_file_url}


        harfile_name = self.task_inputs.user_inputs.get('HarFile')
        harfile_ext = harfile_name.split(".")[-1].lower()
        if harfile_ext != "har":
            log_file_url, error = self.upload_log_file({'error': f"Provided file type is not supported. Please upload a file with the 'har' extension. The provided file is of type '{harfile_ext}'"})
            if error:
                return {'error': error}
            return {"LogFile": log_file_url}

        file_bytes, error = self.download_file_from_minio(harfile_name)
        if error:
            log_file_url, error = self.upload_log_file({'error': error})
            if error:
                return {'error': error}
            return {"LogFile": log_file_url}

        if not file_bytes:
            log_file_url, error = self.upload_log_file({'error': 'Failed to download HAR file or file is empty'})
            if error:
                return {'error': error}
            return {"LogFile": log_file_url}

        try:
            file_content = file_bytes.decode("utf-8")
            file_content = json.loads(file_content)

            if not cowdictutils.is_valid_key(file_content, "log"):
                raise ValueError("Invalid file")
        except (json.JSONDecodeError, ValueError):
            log_file_url, error = self.upload_log_file({'error': 'The provided file is invalid'})
            if error:
                return {'error': error}
            return {"LogFile": log_file_url}

        file_content = file_content["log"]
        
        entries = file_content["entries"] if cowdictutils.is_valid_key(file_content, "entries") else []
        
        system = ""
        if len(entries) > 0 :
        
            resource_id, short_id = self.get_resource_id_from_entry(entries[0])
            system = PublicSuffixList().get_public_suffix(urllib.parse.urlparse(resource_id).netloc )
            
        csp_report =[]
        for entry in entries:
            
            report = None
            response = entry.get("response" , None)
            if response == None :
                continue
            
            response_headers = response.get("headers" , None) 
            
            if response_headers == None :
                continue
            
            csp_header = self.fetch_csp_header(response_headers)
            
            if csp_header == "" :
                
                compliance_details = {
                    "CSPHeaderPresent" : "false",
                    "BasicSyntaxIssues" : None,
                    "SecurePolicyIssues" : None,
                    "DeprecatedPolicyIssues" : None,
                    "ValidationStatusCode": "CH_NP",
                    "ValidationStatusNotes":"CSP header not present",
                    "ComplianceStatus": "NON_COMPLIANT",
                    "ComplianceStatusReason": "The absence of CSP (Content-Security-Policy) is non-compliant as it exposes the web application to potential security risks, lacking essential protection against various web-based attacks like XSS (Cross-Site Scripting).",
                    }
                
                report = self.generate_standard_schema(entry , compliance_details , system) 
                
            else: 
                validation_notes = ""
                validation_status_code = ""
                invalid_directives_present = False
                unsafe_directives_present = False
                deprecated_directives_present = False
                
                directives = self.parse_csp_header(csp_header)
                basic_syntax_issues ,deprecated_directives , secure_policy_issues = self.validate_csp(directives)

                if len(basic_syntax_issues) != 0 :
                    invalid_directives_present = True
                    validation_status_code = "CH_P_ID_P_UD_NP_DD_NP"
                    validation_notes =  "CSP header present. Invalid directive Present. Unsafe directive Not Present. Deprecated directive Not Present."
                    complaince_status = "NON_COMPLIANT"
                    compliance_status_reason = "The Content-Security-Policy header is present, but it contains invalid directives. Invalid directives indicate that the CSP is not correctly configured according to the CSP specification, potentially allowing unintended resource loading or execution, which can lead to security vulnerabilities such as XSS (Cross-Site Scripting) attacks. Compliance standards require removing invalid directives to ensure the CSP effectively mitigates these risks. Therefore, this configuration is marked as non-compliant due to the presence of invalid directives."
                    
                if len(secure_policy_issues) != 0 :
                    unsafe_directives_present = True
                    if invalid_directives_present :
                        validation_status_code = "CH_P_ID_P_UD_P_DD_NP"
                        validation_notes =  "CSP header present. Invalid directive Present. Unsafe directive Present. Deprecated directive Not Present."
                        complaince_status = "NON_COMPLIANT"
                        compliance_status_reason = "The Content-Security-Policy header is present, but it contains both invalid and unsafe directives. Invalid directives indicate that the CSP is not correctly configured according to the CSP specification, potentially allowing unintended resource loading or execution, which can lead to security vulnerabilities such as XSS (Cross-Site Scripting) attacks. Additionally, the presence of unsafe directives poses a direct security risk by allowing potentially harmful scripts or resources to be loaded. Compliance standards require removing invalid and unsafe directives to ensure the CSP effectively mitigates these risks. Therefore, this configuration is marked as non-compliant due to the presence of both invalid and unsafe directives simultaneously."
                    else:
                        validation_status_code = "CH_P_ID_NP_UD_P_DD_NP"
                        validation_notes =  "CSP header present. Invalid directive Not Present. Unsafe directive Present. Deprecated directive Not Present."
                        complaince_status = "NON_COMPLIANT"
                        compliance_status_reason = "The Content-Security-Policy header is present, and while it does not contain invalid directives, the presence of unsafe directives poses a security risk. Compliance standards emphasize the exclusion of unsafe directives to mitigate vulnerabilities such as cross-site scripting (XSS) attacks. Therefore, this configuration is marked as non-compliant due to the presence of unsafe directives."
                        
                if len(deprecated_directives) != 0 :
                    deprecated_directives_present = True
                    if invalid_directives_present :
                        validation_status_code = "CH_P_ID_P_UD_NP_DD_P"
                        validation_notes =  "CSP header present. Invalid directive Present. Unsafe directive Not Present. Deprecated directive Present. "
                        complaince_status = "NON_COMPLIANT"
                        compliance_status_reason = "The Content-Security-Policy header is present, but it contains both invalid and deprecated directives. Invalid directives indicate that the CSP is not correctly configured according to the CSP specification, potentially allowing unintended resource loading or execution, which can lead to security vulnerabilities such as XSS (Cross-Site Scripting) attacks. Additionally, using deprecated directives is discouraged as they may not offer effective protection against modern threats. Compliance standards require removing invalid and deprecated directives to ensure the CSP effectively mitigates these risks. Therefore, this configuration is marked as non-compliant due to the presence of both invalid and deprecated directives simultaneously."
                    elif invalid_directives_present and unsafe_directives_present :
                        validation_status_code = "CH_P_ID_P_UD_P_DD_P"
                        validation_notes =  "CSP header present. Invalid directive Present. Unsafe directive Present. Deprecated directive Present."
                        complaince_status = "NON_COMPLIANT"
                        compliance_status_reason = "The Content-Security-Policy header is present, but it contains invalid, unsafe, and deprecated directives simultaneously. Invalid directives indicate that the CSP is not correctly configured according to the CSP specification, potentially allowing unintended resource loading or execution, which can lead to security vulnerabilities such as XSS (Cross-Site Scripting) attacks. Additionally, the presence of unsafe directives poses a direct security risk by allowing potentially harmful scripts or resources to be loaded. Using deprecated directives is discouraged as they may not offer effective protection against modern threats. Compliance standards require removing invalid, unsafe, and deprecated directives to ensure the CSP effectively mitigates these risks. Therefore, this configuration is marked as non-compliant due to the presence of invalid, unsafe, and deprecated directives together."
                    elif  unsafe_directives_present :
                        validation_status_code = "CH_P_ID_NP_UD_P_DD_P"
                        validation_notes =  "CSP header present. Invalid directive Not Present. Unsafe directive Present. Deprecated directive Present."
                        complaince_status = "NON_COMPLIANT"
                        compliance_status_reason = "The Content-Security-Policy header is present, but it contains both unsafe and deprecated directives. This configuration is considered non-compliant because using unsafe directives can lead to security vulnerabilities, and employing deprecated directives is discouraged as they may not offer effective protection against modern threats. Compliance standards recommend removing unsafe and deprecated directives to maintain a secure web environment. Therefore, this configuration is marked as non-compliant due to the presence of unsafe and deprecated directives simultaneously."                 
                    else:
                        validation_status_code = "CH_P_ID_NP_UD_NP_DD_P"
                        validation_notes =  "CSP header present. Invalid directive Not Present. Unsafe directive Not Present. Deprecated directive Present."
                        complaince_status = "NON_COMPLIANT"
                        compliance_status_reason = "The Content-Security-Policy header is present, and while it does not contain invalid or unsafe directives, the presence of deprecated directives indicates an outdated security configuration. Compliance standards recommend avoiding deprecated directives to maintain robust security practices and reduce risks associated with outdated security policies. Therefore, this configuration is marked as non-compliant due to the use of deprecated directives."

                if validation_notes == "" :
                    validation_status_code = "CH_P_ID_NP_UD_NP_DD_NP"
                    validation_notes =  "CSP header present. Invalid directive Not Present. Unsafe directive Not Present. Deprecated directive Not Present."
                    complaince_status = "COMPLIANT"
                    compliance_status_reason = "The Content-Security-Policy header is present and correctly configured without invalid, unsafe, or deprecated directives, ensuring the website adheres to current security best practices and mitigates risks associated with unauthorized resource loading and deprecated security policies."

                compliance_details = {
                    "ValidationStatusCode": validation_status_code,
                    "ValidationStatusNotes": validation_notes,
                    "ComplianceStatus": complaince_status,
                    "ComplianceStatusReason": compliance_status_reason,
                    }
                
                compliance_details["CSPHeaderPresent"] =  "true"
                compliance_details["BasicSyntaxIssues"] = None if len(basic_syntax_issues) == 0 else basic_syntax_issues
                compliance_details["SecurePolicyIssues"] = None if len(secure_policy_issues) == 0 else secure_policy_issues
                compliance_details["DeprecatedPolicyIssues"] = None if len(deprecated_directives) == 0 else deprecated_directives

                report = self.generate_standard_schema(entry , compliance_details, system) 
                    
            
            if report :
                csp_report.append(report)
                
        file_url, error = self.upload_file_to_minio(
            file_name=f"CSPVulnerabilityReport-{str(uuid.uuid4())}.json",
            file_content=json.dumps(csp_report),
            content_type="application/json"
        )
                

        response = {
            "CSPVulnerabilityReport" : file_url ,
        }

        return response
    
    def get_resource_id_from_entry(self , entry):
        resource_id = ""
        request = entry.get("request" ,"")
        if request != "" :
            resource_id = request.get("url" ,"")
            
        if resource_id == "" :
            return "" , ""
        
        short_resource_id = resource_id
        
        if len(resource_id) > 30 :
            short_resource_id = short_resource_id[:30]
        return resource_id , short_resource_id
    
    def generate_standard_schema(self, entry , compliance_details , system):
        
        resource_id , short_resource_id = self.get_resource_id_from_entry(entry)
        if resource_id == "" :
            return None
        
        resource_name = urllib.parse.urlparse(resource_id).netloc 
        if resource_name == "" :
            resource_name = "N/A"
            
        
        invalid_directives_present = "false"
        unsafe_directives_present = "false"
        deprecated_directives_present = "false"
        
        if compliance_details["BasicSyntaxIssues"] != None :
            invalid_directives_present = "true"
            
        if compliance_details["SecurePolicyIssues"]  != None  :
            unsafe_directives_present = "true"
            
        if compliance_details["DeprecatedPolicyIssues"]  != None  :
            deprecated_directives_present = "true"

        data = {
                # Meta
                "System": system,
                "Source": "compliancecow",

                # Resource info
                "ResourceID": resource_id,
                "ShortResourceID": short_resource_id,
                "ResourceName": resource_name,
                "ResourceType": "http transaction",
                "ResourceURL":              "N/A",
                "ResourceTags": "N/A",

                # Data
                "InvalidDirectives" : compliance_details["BasicSyntaxIssues"]  ,
                "UnsafeDirectives" : compliance_details["SecurePolicyIssues"]  ,
                "DeprecatedDirectives" : compliance_details["DeprecatedPolicyIssues"]  ,
                "CSPHeaderPresent" : compliance_details["CSPHeaderPresent"],
                "InvalidDirectivesPresent" : invalid_directives_present,
                "UnsafeDirectivesPresent" : unsafe_directives_present,
                "DeprecatedDirectivesPresent" : deprecated_directives_present,

                # Compliance details
                "ValidationStatusCode": compliance_details["ValidationStatusCode"],
                "ValidationStatusNotes": compliance_details["ValidationStatusNotes"],
                "ComplianceStatus": compliance_details["ComplianceStatus"],
                "ComplianceStatusReason": compliance_details["ComplianceStatusReason"],
                "EvaluatedTime": self.get_current_datetime(),

                # User editable data
                "UserAction":"",

                # Action editable data
                "ActionStatus":"",
                "ActionResponseURL":""
            }
        
        
        return data
    
    def parse_csp_header(self,csp_header):
        directives = {}
        if csp_header:
            policies = csp_header.split(';')
            for policy in policies:
                if policy.strip():
                    directive, *sources = policy.strip().split(' ')
                    directives[directive] = sources
        return directives
    
    def validate_csp(self,directives):
        
        valid_directives = {
                "base-uri", "block-all-mixed-content", "child-src", "connect-src",
                "default-src", "fenced-frame-src", "font-src", "form-action", "frame-ancestors",
                "frame-src", "img-src", "manifest-src", "media-src", "object-src", "plugin-types",
                "prefetch-src", "referrer", "report-to", "report-uri", "require-trusted-types-for",
                "sandbox", "script-src", "script-src-attr", "script-src-elem",
                "style-src", "style-src-attr", "style-src-elem", "trusted-types",
                "upgrade-insecure-requests", "worker-src"
                }
        
        depricated_directives = {
                "block-all-mixed-content", "plugin-types","prefetch-src",
                "referrer", "report-uri"
                }
        
        invalid_directives = []
        deprecated_directives = []
        unsafe_directives = []
        
        for directive in directives:
            
            if directive not in valid_directives :
                invalid_directives.append(directive)
                
            elif directive in depricated_directives :
                deprecated_directives.append(directive )
                
            
            else:
                unsafe_directives_value = self.check_secure_policy(directives[directive])
                if unsafe_directives_value :
                    unsafe_directives.append({
                                directive : unsafe_directives_value
                                })
                                                                   
                
                
        return invalid_directives , deprecated_directives, unsafe_directives 

    def check_secure_policy(self, current_directives):
        
        
        unsafe_keywords =  [
            "unsafe-inline", "unsafe-eval", "unsafe-hashes", "wasm-unsafe-eval", "*"
                ]
        unsafe_directives = []
        
        for current_directive in current_directives:
            current_directive = current_directive.replace("'", "")
            
            if current_directive in unsafe_keywords :
                unsafe_directives.append(current_directive)

        return unsafe_directives
    
    def fetch_csp_header(self,headers):
        
        csp_config = ""
        for header in headers :
            name = (header.get("name" , "")).lower()
            if name == "content-security-policy" or  name == 'content-security-policy-report-only' :
                csp_config = header.get("value" , "")
                
            if csp_config != "" :
                break
            
        return csp_config
    
    def upload_log_file(self, error_data):
        if not isinstance(error_data, list):
            error_data = [error_data]
        file_url, error = self.upload_file_to_minio(
            file_content=error_data,
            file_name=f"LogFile-{str(uuid.uuid4())}.json",
            content_type="application/json"
        )
        if error:
            return None, {'error': f"Error while uploading LogFile :: {error}"}
        return file_url, None
    
    def get_current_datetime(self):
        current_time = datetime.utcnow()
        formatted_time = current_time.strftime('%Y-%m-%dT%H:%M:%S.%fZ')
        return formatted_time
    
    def check_inputs(self):
        task_inputs = self.task_inputs
        if task_inputs is None:
            return 'Task inputs are missing'
        user_object = self.task_inputs.user_object
        if (
            user_object is None
            or user_object.app is None
            or user_object.app.application_url is None
            or user_object.app.user_defined_credentials is None
        ):
            return 'User defined credentials are missing"'
        if self.task_inputs.user_inputs is None:
            return 'User inputs are missing'
        if self.task_inputs.user_inputs.get("HarFile") is None or self.task_inputs.user_inputs.get("HarFile") == "<<MINIO_FILE_PATH>>":
            return 'HarFile is missing. Please upload a valid HarFile'
        return None



